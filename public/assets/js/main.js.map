{"version":3,"sources":["0_variables.js","1_data.js","2_render.js","3_listeners.js","4_fav_render.js","5_filter.js","6_fav_listeners.js","7_reset.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["'use strict';\n\n//CONSTANTES GLOBALES\n\n//Traigo los elementos de html y los guardo en variables\nconst searchInput = document.querySelector('.js-input');\nconst searchBtn = document.querySelector('.js-btn');\nconst cardsList = document.querySelector('.js-list');\nconst favCardsList = document.querySelector('.js-fav-list');\nconst resetButton = document.querySelector('.js-reset-btn');\n\n// Declaro un array vacío donde luego irán los datos de la API\nlet charactersList = [];\n\n//Array de favoritos (también vacío) a partir de las tarjetas seleccionadas\nlet favouriteCharacters = [];\n","'use strict';\n\n//RECOJO DATOS DE LA API. Vuelvo a la primera versión de la función con fetch, porque del localStorage sólo quiero las favoritas, y había guardado todas\nfunction getData() {\n  fetch('https://breakingbadapi.com/api/characters')\n    .then((response) => response.json())\n    .then((data) => {\n      charactersList = data;\n      renderCharactersList();\n    });\n}\n\nfunction getLocalFav() {\n  const favouritesInLocalSt = JSON.parse(localStorage.getItem('favourites'));\n\n  if (favouritesInLocalSt !== null) {\n    favouriteCharacters = favouritesInLocalSt;\n    renderFavCharacters();\n  }\n}\n\n//Al abrir la página, quiero los datos de la API\ngetData();\n//y mis favoritas guardadas en localStorage\ngetLocalFav();\n","'use strict';\n\n//Función para pintar la tarjeta en sí, con sus elementos de html\nfunction renderCards(character) {\n  //Cambio la función para renderizar las tarjetas con DOM avanzado\n\n  const liElement = document.createElement('li');\n  liElement.classList.add('cards-list-item');\n\n  const articleElement = document.createElement('article');\n  const current = character.char_id;\n\n  const cardFavouriteIndex = favouriteCharacters.findIndex(\n    (eachCardObj) => eachCardObj.char_id === current\n  );\n\n  if (cardFavouriteIndex !== -1) {\n    articleElement.classList.add('card', 'js-fav-card', 'selected');\n  } else {\n    articleElement.classList.add('card', 'js-card');\n  }\n\n  articleElement.setAttribute('id', character.char_id);\n\n  const imgElem = document.createElement('img');\n  imgElem.setAttribute('src', character.img);\n  imgElem.setAttribute('alt', `Picture of ${character.name}`);\n  imgElem.setAttribute('title', character.name);\n  imgElem.classList.add('card-img');\n\n  const nameElement = document.createElement('h3');\n  nameElement.classList.add('card-name');\n  const textNameElement = document.createTextNode(character.name);\n\n  const statusElement = document.createElement('p');\n  statusElement.classList.add('card-status');\n  const textStatusElement = document.createTextNode(character.status);\n\n  nameElement.appendChild(textNameElement);\n  statusElement.appendChild(textStatusElement);\n\n  articleElement.appendChild(imgElem);\n  articleElement.appendChild(nameElement);\n  articleElement.appendChild(statusElement);\n\n  liElement.appendChild(articleElement);\n\n  const card = liElement;\n\n  return card;\n}\n\n//Función para pintar la lista completa de tarjetas de personajes\nfunction renderCharactersList() {\n  cardsList.innerHTML = '';\n  for (const card of charactersList) {\n    cardsList.appendChild(renderCards(card));\n  }\n\n  cardListeners();\n}\n","'use strict';\n\n// Función para buscar los obj seleccionados y generar un nuevo array con ellos\nfunction handleClickCard(event) {\n  //Recupero la línea de código que me pintaba la tarjeta en el listado general (ahora la quiero pintada en ambos listados)\n  event.currentTarget.classList.add('selected');\n\n  const current = parseInt(event.currentTarget.id);\n\n  const selectedCard = charactersList.find(\n    (eachCardObj) => eachCardObj.char_id === current\n  );\n\n  //Busco el problema y era que una era string y otra number, uso typeof, por eso creo una variable donde recoger el nuevo valor (en nº) para comparar\n\n  const cardFavouriteIndex = favouriteCharacters.findIndex(\n    (eachCardObj) => eachCardObj.char_id === current\n  );\n\n  //Si no está en favoritos, haz el push\n  if (cardFavouriteIndex === -1) {\n    favouriteCharacters.push(selectedCard);\n  } else {\n    //añado la opción de que si el usuario vuelve a hacer click en el listado a una tarjeta favorita, también la quite de favoritos (no sólo clickando en la x de favoritas)\n    favouriteCharacters.splice(cardFavouriteIndex, 1);\n    event.currentTarget.classList.remove('selected');\n  }\n  //guardo el listado de favoritas en localStorage, con las actualizaciones del if/else\n  localStorage.setItem('favourites', JSON.stringify(favouriteCharacters));\n\n  renderFavCharacters();\n}\n\n//Función que crea un bucle para recorrer los elementos del array generado con QSA y así nos permite aplicarle el EVENTLISTENER a cada tarjeta del listado general\nfunction cardListeners() {\n  const allCharacterCards = document.querySelectorAll('.js-card');\n  for (const eachCard of allCharacterCards) {\n    eachCard.addEventListener('click', handleClickCard);\n  }\n}\n","'use strict';\n\n//Función para pintar la tarjeta en sí, esta vez para los personajes favoritos\nfunction renderFavCard(favCharacter) {\n  //Cambio la función para renderizar las tarjetas de favoritos con DOM avanzado\n\n  const liElement = document.createElement('li');\n  liElement.classList.add('cards-list-item');\n\n  const articleElement = document.createElement('article');\n  articleElement.classList.add('card', 'js-fav-card', 'selected');\n  articleElement.setAttribute('id', favCharacter.char_id);\n\n  const crossElement = document.createElement('i');\n  crossElement.classList.add('fa-solid', 'fa-square-xmark');\n\n  const imgElem = document.createElement('img');\n  imgElem.setAttribute('src', favCharacter.img);\n  imgElem.setAttribute('alt', `Picture of ${favCharacter.name}`);\n  imgElem.setAttribute('title', favCharacter.name);\n  imgElem.classList.add('card-img');\n\n  const nameElement = document.createElement('h3');\n  nameElement.classList.add('card-name');\n  const textNameElement = document.createTextNode(favCharacter.name);\n\n  const statusElement = document.createElement('p');\n  statusElement.classList.add('card-status');\n  const textStatusElement = document.createTextNode(favCharacter.status);\n\n  nameElement.appendChild(textNameElement);\n  statusElement.appendChild(textStatusElement);\n\n  articleElement.appendChild(crossElement);\n  articleElement.appendChild(imgElem);\n  articleElement.appendChild(nameElement);\n  articleElement.appendChild(statusElement);\n\n  liElement.appendChild(articleElement);\n\n  const favCard = liElement;\n  return favCard;\n}\n\n//Función para pintar el listado de tarjetas de mis favoritos, ahora con DOM\nfunction renderFavCharacters() {\n  favCardsList.innerHTML = '';\n\n  for (const favCard of favouriteCharacters) {\n    favCardsList.appendChild(renderFavCard(favCard));\n  }\n  paintReset();\n\n  favCardListeners();\n}\n","'use strict';\n\n//Función para FILTRAR según lo que se escriba en el input (una vez dado al botón)\nfunction filterCards() {\n  let searchedCharacter = searchInput.value.toLowerCase();\n  cardsList.innerHTML = '';\n\n  const filteredCharacters = charactersList.filter((character) =>\n    character.name.toLowerCase().includes(searchedCharacter)\n  );\n\n  for (const character of filteredCharacters) {\n    cardsList.appendChild(renderCards(character));\n  }\n\n  if (searchedCharacter === '') {\n    renderCharactersList();\n  }\n}\n\n//Función manejadora del botón de buscar, que nos lleva a la función de filtrado\nfunction handleSearch(event) {\n  event.preventDefault();\n  filterCards();\n  //Añado de nuevo la función cardListeners porque si no no me dejaba marcar como favoritas los resultados de búsqueda\n  cardListeners();\n}\n\n//Función manejadora del input, para que al borrar nos enseñe de nuevo todo el listado\nfunction handleResetInput(event) {\n  event.preventDefault();\n  let inputData = searchInput.value.toLowerCase();\n  if (inputData === '') {\n    renderCharactersList();\n  }\n}\n\n//Evento para escuchar al botón de buscar\nsearchBtn.addEventListener('click', handleSearch);\n\n//Nuevo evento para escuchar al input y que me vuelva a enseñar todas las tarjetas\nsearchInput.addEventListener('input', handleResetInput);\n","'use strict';\n\n//Función para eliminar la tarjeta de favoritos, al clickarla\nfunction handleClickFavCard(event) {\n  const current = parseInt(event.currentTarget.id);\n  let cardFromWholeList = '';\n\n  const cardFavouriteIndex = favouriteCharacters.findIndex(\n    (eachCardObj) => eachCardObj.char_id === current\n  );\n\n  favouriteCharacters.splice(cardFavouriteIndex, 1);\n  const findInWholeList = charactersList.find(\n    (eachCardObj) => eachCardObj.char_id === current\n  );\n\n  console.log(findInWholeList);\n  cardFromWholeList = renderCards(findInWholeList);\n  cardFromWholeList.classList.remove('selected');\n  console.log(cardFromWholeList);\n\n  renderFavCharacters();\n  renderCharactersList();\n\n  localStorage.setItem('favourites', JSON.stringify(favouriteCharacters));\n}\n\n//Bucle que recorre el array, esta vez para añadir listeners a las tarjetas favoritas\nfunction favCardListeners() {\n  const favCharacterCards = document.querySelectorAll('.js-fav-card');\n\n  for (const eachCard of favCharacterCards) {\n    eachCard.addEventListener('click', handleClickFavCard);\n  }\n}\n","'use strict';\n\nfunction paintReset() {\n  if (favouriteCharacters.length !== 0) {\n    resetButton.classList.remove('hidden');\n  } else {\n    resetButton.classList.add('hidden');\n  }\n\n  function handleResetButton() {\n    favCardsList.innerHTML = '';\n    favouriteCharacters = [];\n    localStorage.setItem('favourites', favouriteCharacters);\n    resetButton.classList.add('hidden');\n    const allCharacterCards = document.querySelectorAll('.js-card');\n    for (const eachCard of allCharacterCards) {\n      eachCard.classList.remove('selected');\n    }\n  }\n\n  resetButton.addEventListener('click', handleResetButton);\n}\n"]}